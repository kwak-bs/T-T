# 다이나믹 프로그래밍

> 큰 문제를 작은 문제로 나눠서 푸는 알고리즘
>
> Dynamic programming의 다이나믹은 아무 의미가 없다.

#### 두 가지 속성을 만족해야 dp로 문제를 풀 수 있다.

1. Overlapping Subproblem (겹치는 작은 문제, 부분 문제) ex) 피보나치 수
   - 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.
   - 문제를 작은 문제로 쪼갤 수 있다.
2. Optimal Substructure (최적 부분 구조)
   - 문제의 정답을 작은 문제의 정답에서 구할 수 있다.
   - ex) 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다. 

#### 이 둘을 합칠 수가 있다.

- dp에서 각 문제는 한 번만 풀어야 한다.
- Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다. 
- 따라서, 정답을 한 번 구했으면 정답을 어딘가에 메모해놓는다.
- 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다. 
- 메모를 한다고 해서 영어로 Memoization이라고 한다.

##### dp는 모든 문제를 풀어야 하지만 모든 문제는 한 번만 풀어야한다. 

- 시간 복잡도는 문제의 갯수 X 문제 1개를 푸는 시간이다. (다 그런건 아니다.)



## Top-down

> 위에서 부터 내려오는 방식

- 가장 큰 문제를 호출함과 동시에 작은 문제를 풀어간다. 
- 작은 문제들을 다 해결했으면 그 값들을 활용하여 호출한 가장 큰 문제의 답을 도출한다.

- 주로 재귀 함수를 이용한다.



## Bottom-up

> 가장 작은 문제를 해결하고 큰 문제를 해결한다.

- ex) 피보나치를 예로 들면, 먼저 f(0), f(1)을 해결하고 원하는 f(n)의 값을 도출한다. 
- 주로 반복문을 이용한다.

- top down 이나 bottom up의 시간 복잡도는 같다. 편한쪽 사용하자

## 점화식

> 문제를 푸는데 필요한 재귀식.

1. 점화식의 정의를 세운다 . ex) dp[n] = n번째 피보나치 수  (점화식은 글로 작성한다.)
2. 문제를 작게 만들 수 있는 방법을 찾아야 한다. ex) N번째 피보나치 수는 N-1번째와 N-2번째를 더해서 만든다. (dp[n] = dp[n-1] + dp[n-2])